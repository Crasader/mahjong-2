#include <iostream>
#include <algorithm>
					
#pragma comment(lib,"../Debug/mj_robot.lib")
#include "../mj_robot/mj_robot.h"
#include "../mj_robot/mj_header.h"

using namespace std;

typedef unsigned char BYTE;


//扑克转换
BYTE SwitchToCardIndex(BYTE cbCardData)
{
//	ASSERT(IsValidCard(cbCardData));
	//if (m_byGodsCardData>0)
	//{
	//	if (BAIBAN_CARD_DATA == cbCardData)    // 将白板跟财神交换
	//	{
	//		cbCardData = m_byGodsCardData;
	//	}
	//	else if (m_byGodsCardData == cbCardData)
	//	{
	//		cbCardData = BAIBAN_CARD_DATA;
	//	}
	//}
	return ((cbCardData&MASK_COLOR) >> 4) * 9 + (cbCardData&MASK_VALUE) - 1;
}


static const BYTE as[MAX_REPERTORY] =
{
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,						//万子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,						//索子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,						//同子
	0x31,0x32,0x33,0x34,0x35,0x36,0x37,									//番子
	0x31,0x32,0x33,0x34,0x35,0x36,0x37,									//番子
	0x31,0x32,0x33,0x34,0x35,0x36,0x37,									//番子
	0x31,0x32,0x33,0x34,0x35,0x36,0x37,									//番子
};

int main(void) {

	stCardData card;
	card.card[0] = 122;
	card.size = 1;
	SRSetGameCardData(card, card);

	int i = SwitchToCardIndex(0x11);

	//BYTE temp_card1[255] = { 0x01, 0x02, 0x03,
	//	0x03, 0x04, 0x05,
	//	0x04, 0x05, 0x06,
	//	0x05, 0x06, 0x07,
	//	0x05, 0x11 };
	BYTE temp_card[255] = { 0x01, 0x02, 0x03,
							0x01, 0x02, 0x03,
							0x01, 0x12, 0x13,
							0x13, 0x14, 0x15,
							0x01, 0x11 };

	memcpy(card.card, temp_card, sizeof(temp_card));
	
	SRSetGameProtagonists(enDirection::East);
	SRSetPlayerCardData(enDirection::East, card);
	BYTE temp_out_card = 0;
	SRAskOutCard(0x11, &temp_out_card);
	SRAskOutCard(0x01, &temp_out_card);
	//SRAskOutCard(0x01, &temp_out_card);
	//SRAskOutCard(0x01, &temp_out_card);
	//SRSetPlayerCardData(enDirection::East, card);

	

	// 胡牌分析

	  // 胡牌权重
	  
	  // 牌局前后期分析


	// 听牌分析
	  // 听牌打生牌 （送人吃碰，快速摸牌）


	// 牌型分析
	  // 必留牌型 刻子 杠牌 字对
	  // 成型牌 三搭子、对子、
	  // 缺牌牌型


	
	// 出牌分析

	  // 如遇抉择牌型
	  // 有熟张出熟张
	  // 走生张时应再判断
	      // 1. 生张  2. 


	  

	  // 确定与摸进的牌相关的关联牌

	  // 搭子分析
	    // 有边搭，拆边搭

		  // 四搭子分析 
	    
			// 前期出张，中后期出尾张

		  // 两连搭分析
	    
			

	  // 对子分析


	return 0;
}